= 寄存器操作 =

寄存器有26个字母寄存器可以使用；可以使用大写字母将文本附加到已有内容后。如果在你关闭文件之前还没想到这将这些内容贴在哪里也没关系，
用`:wviminfo my_viminfo`‘命令。
下一次编辑时输入`:rviminfo! my_viminfo`‘或者在命令行用这个命令运行`gvim -i my_viminfo myfile`
`:reg`看寄存器的内容都在的。

vim常用的寄存器：

‘”‘     无名寄存器，包含最近删除或抽出的文本
‘%’     当前文件名
‘#’     轮换文件名
‘*’     剪贴板内容 (X11: 主选择)
‘+’     剪贴板内容
‘/’     最近的搜索模式
‘:’     最近的命令行
‘.’     最近插入的文本
‘-’     最近的行内 (少于一行) 删除
‘=’     表达式寄存器；你会被提示输入一个表达式 (见
在编辑窗口与命令窗口间交换内容

编辑窗口的文本可以放进寄存器。搜索式样和上一条Ex命令被放进了只读寄存器"/和":。

使用Ctrl-R转义
/<Ctrl-R>e/
使用<C-R>的方式可适用于各种输入的环境中：在插入模式输入时、在命令窗口输入时、在搜索时。

无名寄存器：按Ctrl-R再按输入"
":保存了上一条Ex命令。
"/保存了上一条搜索式样。

在buffer之间及程序之间交换内容

寄存器是全局的变量。在Vim中打开的所有文件2，共享这些寄存器。你可以在不同的文件之间交换内容。

通过寄存器"*和"+，Vim可以与其他程序交换信息。在Windows中这两个寄存器是一样的。在Linux中这两个寄存器则有所不同。
:help gui-selections
:help x11-selection

寄存器可以做为宏

跟一般的变量相比寄存器还有一个最大的特点就是寄存器本身可以做为宏使用。如果你有用过一般模式命令q的话就会发现q录制的击键序列就是存在寄存器中的，并且可以直接使用寄存器执行命令。现在做做实验，新建一文档随便输入几行文字。输入：
qeggddq
上面这条命令录制了一个宏并保存到寄存器e中。这个宏的作用是回到第一行并删除该行。现在看一下寄存器的内容：
:reg e
就是你刚才的键盘命令ggdd。要运行刚录制的键盘操作在一般模式输入@e就可以运行了，输入3@e会将前三行删除。
当然你不一定要用q来录制宏——因为寄存器也是变量。
:let @e="/删除本行/^Mdd:w^M"
@e
上面的^M表示的是回车键。可不是输入^再输入M，而是输入Ctrl-V（Windows是Ctrl-Q）再按回车键这时就会出现^M表示这是一个回车键。常见的还有^[表示的是<ESC>键。输入的方法也是一样按Ctrl-V再按Esc键。这样输入控制字符的方式是传统的Vi方法。在Vim中也支持用按键名表示这些控制字符。比如<CR>表示回车键3所以上面的命令也可表示为：
:let @e="/删除本行/\<CR>dd:w\<CR>"
这里一定要用双引号，我们在“脚本”一篇中已经讲到了，在单引号中的字串会被当成普通字串。后面这种表示控制字符的方式与'cpoptions'的设置有关，虽然在默认情况下都是可行的但是建议使用第一种方式。不过为了更好的可读性在教程中我们还是可能使用后面这种方式表示控制字符。
正因为寄存器可以直接执行所以":可以用来执行上一条在命令窗口使用的命令：
:@:
记得最后要按回车执行。当然现在由于命令行的历史功能这种用法没有什么实用价值。

在重定向命令中使用
重定向命令（:redir）是一个较常用的技巧。所有的字母寄存器、@*、无名寄存器（@"）都可以在重定向命令中使用。还是用个例子说明好了：
假设你的小说家朋友寄了一本小说的初稿给你，但显然他没有整理文本的习惯——好消息是他这次竟然没用Word写。在你往下看之前你决定先将文档做适当的整理。使用Vim作这种事当然是小菜一碟，只用了10分钟你就将他的小说整理成一份格式整齐的文档了。

第六章 为山九仞
===============

  小明是从不在午时之前离开被褥的，今天却是个例外。他一夜没睡不
  过他却觉得精神比任何时候都好……

  < 省略800行 >
  ……

第七章 功亏一篑
===============

  小明已经很久没像今天这样开心了。从那时到现在已有二十年又一天
  了。对他来讲二十年并不长，能在二十年又三天之内报仇已经是出乎
  自己意料了。何况对方是可是威峦镖局的大当家。想到这里他的眼睛
  眯得更小了……再过两天……只要两天！

但你发现这份初稿没目录，而你看小说的习惯是从目录看起。于是你决定整理一份目录。于是你用了寄存器：
:let @a=""
:g/^第.\{1,3}章 /y A
这两条命令将所有章的标题放到寄存器A中。你可以在需要目录的地方"ap。不过你还想在每章标题后加上该章对应的行号，你知道这时可以用:redir：
:redir @a
:echo "目录："
:g/^第.\{1,3}章 /echo getline(".") . "\t\t\t" . line(".")
:redir END
现在你的寄存器a中有了一个带行号的目录了。只用了几行命令你就漂亮地完成任务了，想到这这里你的眼睛眯得更小了……
注：这里用到的函数是我们在讲折叠时说过的getline(".")，表示返回当前行。line(".")则返回当前的行号。这两个函数的详细用法见文档。通过对这个脚本进行扩充我们甚至可以让它抓取含小节的目录。

上面的例子演示了通过:redir用户能对寄存器的内容进行进一步的加工而不只是简单的摘录，它增加了寄存器的使用范围。这正是与redir之所以成为寄存器重要性质之一的重要原因。在Vim7.0之前的版本中不支持重定向内容到变量，所以寄存器成了唯一选择。考虑到:redir是比较重要的命令，寄存器吃香也就不足为奇了。但在Vim7开始支持重定向内容到变量后，寄存器就没那么重要了——当然如果你希望方便地将重定向的内容插入到文件中的话寄存器仍是理想之选。关于:redir的更多内容，将会另外解说。

表达式寄存器

虽说是寄存器但从各种角度来看这都是个冒牌的寄存器。它的主要作用是实时计算表达式的值。适用的场合：在编辑输入时、在命令窗口输入时、在搜索时。使用的方式是按Ctrl-R再按等号（<C-R>=），接着输入表达式，原来输入的位置就会插入表达式的值。只要是合法的表达式都可以使用。我们知道字串可以做为合法的表达式，所以在插入模式下按Ctrl-R =然后输入"abc"（注意包括"）当前位置就插入了abc。当然我们不会为了输入字串而使用这个寄存器。现在寄存器a中保存着一个数字，你想在当前文档中搜索该数字4倍的另一个数，你当然不想自己计算。这时使用表达式寄存器：/<Ctrl-R>=@a*4<Enter>/<Enter> 。其中<Ctrl-R>不是让你输入这8个字符而是按组合键Ctrl-R，同理<Enter>表示这里按了回车。任何时候当你需要插入一个表达示的值时都可以使用这个寄存器。
如果在输入=号后直接按回车没有输入表达式的话默认使用上一次使用的表达式。

在上一个例子中，如果你把刚才的目录贴在文件的开头（当然是开头），会发现行号不准了因为所有的内容都被往下移了——第一行现在变成在目录后面了。假设增加的目录有25行（不知道有几行？:se nu），现在文章的第一行（是空行）成了第26行。当然这样问题难不倒你，让表达式寄存器重新计算一下行号就行了——将原来的行号加上25。
注：下面几个控制字符的输入方式：^I, ^R, ^M, 分别表示的是Tab键，Ctrl-R，回车。它们的输入方式是按Ctrl-V（或Ctrl-Q）再输入各自所表示的键。

:1,25norm $T^I"ty$:s/[0-9]\+$/^R=@t+25^M/^M
:1,25norm                                                 在1到25行之间（目录区）执行一般模式命令
          $T^I                                             移到行末，将光标定位到最后一个制表符后（也就是第一个数字的位置）
              "ty$                                         将数字复制到寄存器t中
                  :s/[0-9]\+$/                             将行末的数字（每一章的行号）
                              ^R=                          插入表达式
                                  @t+25                    将寄存器t中的数字加上25
                                     ^M                    插入回车结束表达式
                                         /^M               结束s命令并在插入回车键
                                            <Enter>        在全部输入完成后别忘了按回车执行命令
还有一个特殊的地方可以用上表达式寄存器（Vim文档没说这是一个表达式寄存器，但它的使用方式与表达式寄存器完全一样），就是:s命令。:s命令的命令格式为：:s/lhs/rhs/，表示搜索lhs并替换为rhs。一个特殊用法就是当rhs的开头为`\=‘时，这rhs将被视为表达式。lhs将被替换为表达式的值。
:" 例：将当前行中的算术式'42x31'替换为算术式的结果。
:s/42x31/\=42*31/
再回到刚才的例子，中现在我们可以用一种相对优雅的方式计算更新该目录的行号：
:1,25s/[0-9]\+$/\=submatch(0)+25/
注：submatch()只在:s命令rhs的表达式中使用。submatch(0)与原来的&在rhs的作用是一样的。submatch(1)就相当于原来rhs中的\1，依此类推。



创建标记 
ma（m是标记命令，a是所做标记的名称）
小写字母的标记，仅用于当前缓冲区；
大写字母的标记，则可以跨越不同的缓冲区。

跳转标记
'a命令（这里`是反引号（数字键1左边的那一个））

列示标记
:marks（可以列出所有标记）

vim - marks
.    	最近编辑的位置
0-9   	最近使用的文件
∧    	最近插入的位置
'    	上一次跳转前的位置
"    	上一次退出文件时的位置
[    	上一次修改的开始处
]    	上一次修改的结尾处

删除标记

如果删除了做过标记的文本行，那么所做的标记也就不存了。我们不仅可以利用标记来快速移动，而且还可以使用标记来删除文本，例如在某一行用ma做了标记，然后就可以使用d'a来删掉这一行。当然，我们也可以使用y'a命令就可以来复制这一行了。

使用:delmarks a b c命令，可以删除某个或多个标记；而:delmarks! 命令，则会删除所有标记。

利用:help mark-motions命令，可以查看关于标记的更多帮助信息。
命令小结 m 	创建标记
' 	移动到标记的文本行首
` 	移动到标记的光标位置
:marks 	列示所有标记
:delmarks 	删除指定标记
:delmarks! 	删除所有标记



    Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴

    "<寄存器名称>   按下“"”键和另一个字符键，便可以定义一个寄存器。例如：

    "a  "1

    定义寄存器后直接进行操作

    "ayy    将当前行复制到寄存器 a 中
    "ap     将寄存器 a 中的内容粘贴到光标之后

        通常情况下，寄存器 + ( " + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 "+p 粘贴到Vim中；
        您在Vim中，可以使用 "+y 将内容复制到剪贴板，再粘贴到其它程序中
        没有指定寄存器时，Vim使用“无名寄存器”存储内容

    使用撤销分支功能

    可以使用 :undolist 命令查看缓冲区存在的撤销分支列表。而通过 :undo <> 命令则能够移到撤销的某个分支。



强烈建议大家先看看 doc/change.txt 里关于寄存器部分的内容， 我只是简单提及一下，英文不太好的朋友请找 vim 的中文文档。 我要介绍的超强武器是 ctrl-r，在 insert mode 和 command mode 均可使用，功能就是插入寄存器相关内容。 大家可以试试先 copy 或 delete 一些文本，然后在 normal mode 或 command mode 输入 ctrl-r "，看到了吗， 你粘贴了寄存器"的内容。

寄存器的主要有以下几种：

a. The unnamed register ""

   "d", "c", "s", "x" 和 "y" 等涉及删除或拷贝的命令都会将内容存放于此(有例外)。

b. 10 numbered registers "0 to "9          

   0 为最近拷贝的内容，1-9 为最近删除的内容。

   指定 named register 时不会存放于此。

c. The small delete register "-

   删除不多于一行的内容会存在于此。

d. 26 named registers "a to "z or "A to "Z

   小写与大写的区别是，小写是覆盖方式，大写是添加方式。

e. four read-only registers ":, "., "% and "#

   ". 存放上次插入的文本

      有什么用？呵，例如，你输入了一段文本，在另一个地方也要有相同的内容，你输完后，一般要选择并复制一下吧？

      而用这个，直接移到需要插入的地方，i<ctrl-r>. 即可。

   "% 是当前编辑文件全名

      呵，vim 中，% 就是代表当前编辑文件名的变量，好记吧？

      不过，一般直接用 % 就行，例如":!cat %"，vim 会自动扩展。

   "# 是alternate file 名称 (这个我不知道)

   ": 上次执行的命令

      记起来比较容易，冒号就是命令行提示符嘛。这个有些什么用呢？

      在测试配置文件时十分有用，先在命令行输入命令，调试好后，

      在 insert mode 里按Ctrl-R : 就可将该命令插到文件中。

f. the expression register "=

      呵，表达式寄存器，可以输入一个表达式，并插入结果。

g. The selection and drop registers "*, "+ and "~ 

      跟 gui 即 X/Windows 剪贴板有关的变量。

      在 X 中，鼠标中键与系统剪贴板不一样，至于区别，大家自己试验一下，这里给个提示，在命令行下输入 reg 可以列出所有

      寄存器的内容。

h. The black hole register "_ 

      黑洞

i. Last search pattern register "/

      上次搜索的内容。例如，我要搜索一个单词 linuxforum，但我比较懒，先输入 /linux，发现出现很多个 linux，多次按 n 无果，

      难道要重新输入 /linuxforum ? 不用，只需要 /<ctrl-r>/forum 即可。呵，聪明的你一定想到了，用命令行历史也可以调来，按 ctrl-p 或 ctrl-n

      即可上下翻阅。这样也可以嘛，也比较快捷，但要查找 forumlinux 呢？

      用 ctrl-r 的话只需 /forum<ctrl-r>/ 。

7）在使用X Window系统时，有两个特殊的寄存器是需要注意一下的：”"*”访问的寄存器是X的主选择区域（primary selection），”"+”访问的寄存器是X的剪贴板（clipboard）。

=====================================

存入寄存器：

1)在visual模式下，输入：”寄存器y”

2)录制的时候：输入：“q{regsiter}”，使用：在normal模式下，按“＠{regsiter}”
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

调用寄存器：

在插入模式里，按ctrl+r,再按寄存器名，如调用寄存器a：

ctrl+r,a就可以了。

======================================

vim常用的寄存器：

‘”‘     无名寄存器，包含最近删除或抽出的文本
‘%’     当前文件名
‘#’     轮换文件名
‘*’     剪贴板内容 (X11: 主选择)
‘+’     剪贴板内容
‘/’     最近的搜索模式
‘:’     最近的命令行
‘.’     最近插入的文本
‘-’     最近的行内 (少于一行) 删除
‘=’     表达式寄存器；你会被提示输入一个表达式 (见

==============================================

请问如何用vi 复制第5行到第10行并粘贴到第12行之后？

命令行模式下输入
:5,10 co 12

---------------------

延伸一下, 有时候不想费劲看多少行或复制大量行时，可以使用标签来替代

光标移到起始行，输入ma
光标移到结束行，输入mb
光标移到粘贴行，输入mc

然后 :'a,'b co 'c

把 co 改成 m 就成剪切了

-------------------------

Vi 提供了文本移动和复制命令，用户利用这些指令可以方便的复制字符、文字、行还有文本块。
有关的命令如下：
yy                                        将当前行复制到缓冲区
yw                                        将当前单词复制到缓冲区
y1                                        将光标处的一个字符复制到缓冲区
p                                        将缓冲区的信息粘贴到光标的后面
：行号1 ，行号2 copy 行号3                                        将行号1到行号2的内容复制到行号3所在行的后面。
：行号1 ，行号2 move 行号3                                       将行号1到行号2的文本内容移动到行号3所在行的后面。 

= 寄存器操作2 =

(zz)vim寄存器使用详解
来源: ChinaUnix博客 　日期： 2009.02.07 23:12　(共有条评论) 我要评论
 
寄存器用于存储Vim操作中的特定内容，大多数normal命令和部分ex命令都可以指定操作关联的寄存器。寄存器同时也是Vim里特殊的变量，因此可以
在命令行和脚本中被访问，实现一些非常有用的功能。Vim有很多不同类型的寄存器，各司其职，各具其能，若得灵活运用，会令编辑工作轻松高效。本文以
Vim中常见的问题为例，介绍各类寄存器的功能和用法。
1. 编辑操作中的常用功能
:h v_p
:h g@
:h redo-register
Vim
中最常用到的是数字寄存器。当不指定寄存器时，复制操作的内容被保存到"0，删除操作的内容被”压“到"1，同时原先"1的内容转到"2，依此类推，原
先"8转到"9，原先"9的内容丢失。如果指定操作的寄存器，如"ayy和"bdd，则上述的数字寄存器无影响（有些例外情况，详见Vim手册）。未命名
寄存器""保存最近一次复制或删除操作内容，无论是否指定寄存器。还有一个特殊的“黑洞”寄存器"_，当指定其进行删除时，包括""在内的任何寄存器都不
受影响，当然，你也没法把掉进黑洞的物质p出来。
【例1】复制－删除－粘贴
这是经常困扰Vim新手的一个问题：当复制了一个词（yw）然后准备将另外一个词替换掉，自然的想法是删除（dw）后粘贴（p），但dw已经将""更新为被删除的词，p的内容将不是复制的那个了。有几个办法以供选择：
        A. 先p后dw，问题是要重新定位需要删除的部分。你可以用gp/gP试试，它与p/P功能一样，不过光标停留在粘贴出的文字之后，便于随后的删除；
        B. 将删除内容转到黑洞（"_dw），再p；
        C. 指定复制内容（"0p）；
        D. 利用Visual mode下p命令的交换特性（vwp），该操作粘贴指定寄存器的内容，然后删除被选择的文字。这种方法的键盘输入比B和C都方便些。
        E. 利用下面这条map的S命令（S原有功能与cc相同，所以把它改了）。
                " replace text with unnamed register (in all modes)
                function! ReplaceWithUnamed(type)
                        let paste_save=&paste
                        let &paste=1
                        if a:type == 'line'
                          silent exe "normal! '[V']"
                        elseif a:type == 'block'
                          silent exe "normal! `[\`]"
                        elseif a:type == 'char'
                          silent exe "normal! `[v`]"
                        else
                          silent exe "normal! `"
                        endif
                        silent exe "normal! \"_c\"\"
                        let &paste=paste_save
                endfunction
                nmap  S :set opfunc=ReplaceWithUnamedg@
                vmap  S :call ReplaceWithUnamed(visualmode())
          这种方法符合command-motion的操作流程，而且""里的内容不改变，在需要将多处文字替换成同一内容时非常方便。
【例2】进行快速倒序
有时我们需要把一系列的内容交换顺序，比如要把“0x12,0x34,0x56“改成“0x56,0x34,0x12”。假设光标初始在0x12
处，利用数字寄存器的压栈功能，用dw....将5个部分依次删除到"5至"1中，然后用"1p....依次吐出来。巧妙之处在于，若p命令时指定数字寄
存器，则后续的.命令会自动将数字寄存器的编号加一，也就是第一个.执行的是"2p，依次类推。
【例3】多部分复制粘贴
上述技巧还可以用来将多段的文字分别复制到不连续的目的地，比如要把一个函数中某个变量的声明和多处引用（记为A、B、C部分）复制到另外一个函
数中（记为X、Y、Z处）。我们可以依次在A、B、C部分执行删除和undo，然后在Z、Y、X处执行"1p和2个redo，这样将不用在两个函数之间跑
来跑去。
数字寄存器的这一用法还可以用来试选历史删除内容，比如想要粘贴之前某次删除内容，但不知道已经被压到哪层了，则可以"1pu（或者比如"3p，如果你确信不是最近两次删除内容），然后执行几次.u直到想要的内容出来。当然，直接用:di看一下各个寄存器的内容也许更快。
本例也可以把3个部分分别y到"a，"b和"c里，然后到各自的目的地"ap，"bp，"cp。
"a
到"z这26个命名寄存器为编辑操作提供了丰富的资源，比如，程序员可以将常用的代码模版预设到某些寄存器中（利用ftplugin），需要时p出来。命
名寄存器另有一大功能是有"A到"Z与之对应，当用这些大写字母寄存器时，操作的内容是追加到小写字母寄存器原有内容的后面，这在需要收集多处内容时特别
方便，与其它命令结合使用更有妙用，见下例。
【例4】提取匹配行内容
:g/regex/norm "Ayy
上面这条命令把匹配regex的所有行都保存到"a中，当然在运行前需要把"a清空，比如在一个空行上"ayy。
寄存器".保存上一次插入的文字，在需要在多个地方插入相同文字，但又因中间进行了其它修改操作而不能redo时，".非常有用。
寄存器"%和"#保存当前文件和替换文件的文件名，编程写注释头的时候经常用到。需要注意的是，如果文件是在当前目录或其子目录下，文件名是相对路径名，否则是全路径名。
2. 寄存器的其它引用方式
:h i_CTRL-R
:h autocmd
:h redir
除了在normal命令中以"x的形式指定外，插入模式和命令行中输入-x将插入"x的内容。 因为寄存器是Vim中预定义的特殊的变量，还可以在命令行和脚本中以变量的形式（变量名字符前加@）直接读取或修改。
Vim
将最近一次的搜索文字保存在"/中，对应的变量@/决定了n/N命令和查找高亮的对象。@/被所有buffer共享，也就是说在一个buffer里进行新
的查找，其它buffer的匹配高亮和n/N命令也随着更新。如果希望每个buffer都维护自己的查找内容，可以参考下例：
【例5】查找内容本地化
我们利用autocmd功能，在离开buffer时保存"/的值，在进入buffer时恢复：
        :au BufLeave * let b:search_save=@/
        :au BufEnter * if exists("b:search_save") | let @/=b:search_save | endif
还可以把buffer改成window，也就是各个window维护自己的"/，这样在多窗口编辑同一文件时，可以使得查找文字互不干扰。
【例6】信息重定向
有时候我们想把执行ex命令的信息保存下来，Vim提供了:redir命令用来把信息输出重定向到文件或寄存器里。例如：
        :redir @a
        

some commands)
        :redir END
可以定义一个命令来自动完成上述操作：
        :command! -nargs=* Mc redir @"> | try | exe "" | finally | redir END | endtry
例如【例4】也可以这么实现，而且不需要预先清除寄存器。
        :Mc g/regex/p
3. 寄存器与宏
:h q
:h @
:h :@
宏是Vim中非常重要的功能，用来重复执行多个连续操作。当这些操作包含移动、查找、插入、修改等不同类型的命令时，宏显得尤其方便，很多时候
用:s和:g
难以实现的功能，宏都可以轻松搞定。用q录制宏实际上是将键盘输入记录到寄存器的过程，而用@运行宏则是将指定寄存器内容作为normal命令执行的过
程。q命令提供了“所做即所得”，但有时候直接修改寄存器更为方便。比如当你录制完一个非常复杂的宏，但发现有一个小毛病（例如应该是de而不是dw），
不必重新录制一遍，只需要将寄存器的内容p出来修改好再y回去。
【例5】宏的一些技巧
        A. 容许错误：录制过程中如果有错不必放弃重来，可以undo或，只要保证这些操作和处理文本无关，寄存器里有些乱七八糟的东西又何妨。
        B. 分而治之：当录制一个很复杂的宏时可以考虑分成几段，比如qa第一步，qb第二步，然后在qc中调用a和b，各个击破简单易行。
        C. 重复运行：@@命令可以重复上次的宏调用。
        D. 另作它用：q命令是向寄存器里录入命令，你也可以什么都不录！有什么用处？【例4】中清除"a最快的方法：qaq。
Vim
中用":寄存器记录最近一次运行的命令行命令，因此@:是重复上次的命令行操作。值得注意的是，@x宏运行的是normal命令，而@:运行的是Ex命
令。如果某个寄存器"x保存的是Ex命令，你可以用:@x来执行。比如在测试vimrc中的某条命令时，先yy，然后:@"执行。
4. 寄存器求值
寄存器"=与众不同，它不存储文本，而是在可以使用寄存器的场合中提供了用表达式求值并取得其结果的途径。简单的说，就是在指定"=时，Vim会提示输入一个表达式，然后将求值结果返回，至于这串文本如何使用，就看在什么地方使用了。
【例6】十六进制转十进制
在插入模式下输入=，Vim会提示一个=，再输入0x1234，4660就自动插入到当前位置。
【例7】十进制转十六进制
上例的反操作可就没那么方便了，你得用printf函数。下面这个map是将当前的数字替换成十六进制。这个map也许不大易懂，命令其实是【例1】中提到到v_p，只不过用于替换的内容是通过"=进行求值的结果。
        :nmap \h viw"=printf("0x%X",)p
【例8】设置字体
一个常见的问题是如何将guifont的设置写入到_vimrc中，字体名加上字号通常很长，比如我用的是
”Bitstream_Vera_Sans_Mono:h9:cANSI”，照着敲实在太麻烦。当然可以利用【例6】中的:redir把:set
guifont的输出抓出来，但这不是最好的方法。Vim中的选项也是变量，变量名是选项名前加&，因此我们可以方便的用=&guifont得到它。需要其它变量，比如环境变量$HOME，也可以如法炮制。
"=不光用来插入文字，任何能使用寄存器的地方都可以引用。比如用qa录了一个宏后，执行时又想不要最后的dw命令，一个快捷的方法是执行
        @=@a[:-3]
@=运行后面表达式的结果，[x:y]是取字符变量的子字串（串首从0编号，串尾从-1编号），因此@a[:-3]返回除最后dw之外的内容。记住，若要再次运行只需敲@@。
【例9】寄存器求值在在命令行中的示例
        :noremap ,e :e =expand("%:p:h") . "/"
        :noremap ,s :split =expand("%:p:h") . "/"
        :noremap ,S :vsplit =expand("%:p:h") . "/"
        :noremap ,t :tabnew =expand("%:p:h") . "/"
上面几个map提示显示当前文件所作目录下的文件列表，以供edit/split/tabnew，目录名是用=求值的方式获得。（如果你希望当前目录自动跟随当前文件，设置autochdir。）
5. 总结
上面介绍了大部分的寄存器，但没有提及"*、"+和"~，这些寄存器是和GUI的选择和拖拽有关，版内有文章讲解很详细，本文不再累述。有一个常见问题说一下：如果希望和其它程序方便的复制粘贴，可以将剪贴板寄存器"*设为未命名寄存器：
        :set clipboard=unnamed
另外需要说的是，用q:和q/可以打开保存有命令行和查找内容的历史窗口（命令行历史窗口也可以在命令行下敲CTRL-F打开），在其中可以查找、编辑、修改和执行历史命令或查找。
寄存器操作看似都是些细碎的东西，但却是编辑中经常用到的。我们不仅需要掌握:s和:g这类复杂、强大的命令，更需要精通像寄存器这样的小东西，因为这才是决定编辑效率的关键所在——点滴加速，高效之源。
