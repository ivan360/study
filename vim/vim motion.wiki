=================================
光标移动
=================================

1. 动作和操作符
2. 左右动作
3. 上下动作
4. 单词动作
5. 文本对象动作
6. 文本对象选择
7. 位置标记
8. 跳转
9. 其他动作

---------------------------------
CTRL-G 或 g CTRL-G      --如果你想知道在当前文件所在的位置

==============================================================================
1. 动作和操作符

c       -- 修改 (change)
d       -- 删除 (delete)
y       -- 抽出 (yank) 到寄存器 (不改变文本)
~       -- 变换大小写 (只有当 'tildeop' 置位时有效)
g~      -- 变换大小写
gu      -- 变为小写
gU      -- 变为大写
!       -- 通过外部程序过滤
=       -- 通过 'equalprg' (若为空，C-indenting) 过滤
gq      -- 文本排版
g?      -- ROT13 编码
>       -- 右移
<       -- 左移
zf      -- 定义折叠
g@      -- 调用 'operatorfunc' 选项定义的函数

}       -- 移动到一个段落之后的第一行
d}      -- 删除直到下个段落，但不会包含那一行
dj      -- 删除两行 >
dvj     -- 删除当前光标位置到光标下方字符之间字符 >
d<C-V>j -- 删除光标所在和光标下方的字符。

==============================================================================
2. 左右动作

这些命令移动光标到当前行的指定列。除了 "$" 之外 (有可能跨越多行)，它们最多停在
该行的第一列或者行尾。'whichwrap' 选项可以使其中的一些命令跨越行的边界。

h       -- 向左 [count] 个字符
l       -- 向右 [count] 个字符
0       -- 到行的第一个字符
^       -- 到行的第一个非空白字符
$       -- 到行尾。如果给出 [count]，则先往下走 [count-1] 行。
       -- 到当前行的 [count] 屏幕列
f{char} -- 到右侧第 [count] 次出现的字符 {char}
F{char} -- 到左侧第 [count] 次出现的字符 {char}
t{char} -- 直到右侧第 [count] 次出现的字符 {char} 之前
T{char} -- 直到左侧第 [count] 次出现的字符 {char} 之后
;       -- 重复上次的 f、t、F 或者 T 命令 [count] 次
,       -- 反方向重复上次的 f、t、F 或者 T 命令 [count] 次

==============================================================================
3. 上下动作

k                      -- 向上 [count] 行
j                      -- 向下 [count] 行
G                      -- 到第 [count] 行，缺省是最后一行， linewise 行动作。
gg                     -- 到第 [count] 行，缺省是第一行， linewise 行动作。
:[range]               -- 把光标移到 [range] 的最后一行。[range] 也可以是单独一个行号，如 ":1" 或 ":'m"。和 G 不同，此命令不修改 jumplist。
{count}%               -- 到文件的 {count} 百分比处，linewise 行动作。新的行号计算方法如下:({count} * 总行数 + 99) / 100
:[range]go[to] [count] -- 到缓冲区的第 {count} 个字节。缺省的 [count] 是 1，即文件开始处。如果给定 [range]，则最后的一个数字用作字节的序号

==============================================================================
4. 单词动作

这些命令在单词或字串间移动。
word -- 一个单词由字符、数字和下划线序列或者其他的非空白字符的序列组成。单词间可以空白字符 (空格、制表、换行) 分隔。空行也被认作单词。
WORD -- 一个字串由非空白字符序列组成。字串以空白分隔。空行也被认作字串。
w    -- 正向 [count] 个单词
W    -- 正向 [count] 个字串
e    -- 正向到第 [count] 个单词的尾部
E    -- 正向到第 [count] 个字串的尾部
b    -- 反向 [count] 个单词
B    -- 反向 [count] 个字串
ge   -- 反向到第 [count] 个单词的尾部
gE   -- 反向到第 [count] 个字串的尾部

已折叠的行序列被认作由单个字符组成的单词
"w" 和 "W"、"e" 和 "E" 移动到折叠行之后的第一个单词或字串的开始/结尾处
"b" 和 "B" 移动到折叠之前的第一个单词的开始处

==============================================================================
5. 文本对象动作

(  -- 反向 [count] 个句子
)  -- 正向 [count] 个句子
{  -- 反向 [count] 个段落
}  -- 正向 [count] 个段落
]] -- 正向 [count] 个小节或到出现在首列的 '{'。如果带操作符，则同时停留在首列的 '}' 的下方
][ -- 正向 [count] 个小节或到出现在首列的 '}'
[[ -- 反向 [count] 个小节或到出现在首列的 '{'
[] -- 反向 [count] 个小节或到出现在首列的 '}'

这些命令在三类文本对象上移动，见下。
    一个句子以 '.'、'!' 或者 '?' 结尾并紧随着一个换行符、空格或者制表符
    标点和空白字符之间可以出现任何数量的闭括号和引号: ')'、']'、'"' 和 '''
    段落和小节的边界也视为句子的边界。

==============================================================================
6. 文本对象选择

这里是一系列只能在可视模式或操作符后使用的命令
    以 "a" 打头，代表选择一个 ("a"n) 包含空白的对象
    以 "i" 带头，代表选择内含 ("i"nner) 对象

iw       -- "内含单词"，选择 [count] 个单词
aW       -- "一个字串"，选择 [count] 个字串
iW       -- "内含字串"，选择 [count] 个字串

as       -- "一个句子"，选择 [count] 个句子
is       -- "内含句子"，选择 [count] 个句子

ap       -- "一个段落"，选择 [count] 个段落
ip       -- "内含段落"，选择 [count] 个段落

a[       -- "一个 [] 块"，选择 [count] 层 '[' ']' 块
i[       -- "内含 [] 块"，选择 [count] 层 '[' ']' 块

a( 或 ab -- "一个块"，选择 [count] 层块，包括 '(' 和 ')' (见 [()
i( 或 ib -- "内含块"，选择 [count] 层块，但不包括 '(' 和 ')' (见 [()

a> 或 a< -- "一个 <> 块"，选择 [count] 层 <> 块，包括 '<' 和 '>'
i> 或 i< -- "内含 <> 块"，选择 [count] 层 <> 块，但不包括 '<' 和 '>'

at       -- "一个标签块"，选择 [count] 层标签块，包括 "<aaa>"
it       -- "内部标签块"，选择 [count] 层标签块，但不包括

a{ 或 aB -- "一个大块"，选择 [count] 层大块，包括 '{' 和 '}' (见 [{)
i{ 或 iB -- "内含大块"，选择 [count] 层大块，但不包括 '{' 和 '}' (见 [{)

a" 或 a' -- "一个引号字符串"。选择上一个引号开始到下一个引号结束的文本
i" 或 i' -- 类似于 a"、a' 和 a`，但不包括引号

在操作符之后:
非块对象:
        对于 "一个" 命令: 操作符作用于对象与其后的空白。如果其后没有空白或者光标位于对象之前的空白上的话，那么也包括对象之前的空白。
        对于 "内含" 命令: 如果光标在对象之上，那么操作符作用于该对象。如果光标在空白上，那么操作符作用于空白。
块对象:
        操作符作用于光标所在位置所在 (包括光标在括号上的特殊情况) 的块。对于"内含" 命令，不包含包围的括号。而对于 "一个" 命令，则包含之。

在可视模式下:
如果可视区域的起始和结束点在相同位置 (刚输入 "v"):
	选择一个区域，就和使用操作符一样。
如果可视区域的起始和结束点不同:
        若不是块对象，该区域被对象或者下一个对象之前空白所扩展，对于 "一个" 命令，则两者都包含。扩展的方向决定于可视区域和光标的相对位置。
        若是块对象，该块向外扩展一层。

让我们用一系列删除命令来说明，删除的范围从小到大。请 注意 对于单个字符和整行的操作我们用了已有的 Vi 移动命令。
"dl" --删除字符 (缩写: "x")
"diw"--删除内含单词
"daw"--删除一个单词
"diW"--删除内含字串 (见 WORD)
"daW"--删除一个字串 (见 WORD)
"dgn"--  删除下一个前次搜索模式的匹配
"dd"--删除一行
"dis"--删除内含句子
"das"--删除一个句子
"dib"--删除内含 '(' ')' 块
"dab"--删除一个 '(' ')' 块
"dip"--删除内含段落
"dap"--删除一个段落
"diB"--删除内含 '{' '}' 大块
"daB"--删除一个 '{' '}' 大块

请注意
    移动命令和文本对象的区别。移动命令作用于这里 (光标当前位置) 到移动后的位置。
    而对象的使用则会作用于整个对象，而和光标在对象的何处无关。
    例如，我们可以比较 "dw" 和 "daw": "dw" 删除光标位置到下一个单词的起始处，"daw" 删除光标所在的整个单词和其后或其前的空白。


标签块
    "it" 和 "at" 文本对象尝试选择 HTML 和 XML 的匹配标签之间的块。但因为它们并不完全兼容，有一些限制。
    通常的方法是选择 <tag> 直到匹配的 </tag> 为止的内容。"at" 包含标签，"it" 不包含。不过重复 "it" 时标签仍然会包含 (不然不会有任何改变)。
    此外，在没有内容的标签块上使用 "it" 会单独选择引导标签。
    跳过 "<aaa/>" 项目。忽略大小写，即使对大小写应该敏感的 XML 也是如此。
    HTML 里可以有 <br> 或 <meta ...> 这样没有匹配结束标签的标签。它们被忽略。
    这些文本对象能够容忍错误。单独出现的结束标签被忽略。

==============================================================================
7. 位置标记

跳转到一个位置标记有两种方法:
1. 用 ` (反引号):	光标放在指定的位置
2. 用 ' (单引号):	光标放在指定位置所在行的第一个非空字符上

m{a-zA-Z}                -- 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。
m' 或 m`                 -- 设置前次上下文标记。以后可以用 "''" 或者 "``" 跳转到这个位置 (不移动光标，这不是动作命令)。
m[ 或 m]                 -- 设置 '[ 或者 '] 标记。可以用在执行多个命令的操作符的定义中。 (不移动光标，这不是动作命令)。
m< 或 m>                 -- 设置 '< 或者 '> 标记。可以用在改变gv 命令选择的范围。(不移动光标，这不是动作命令)。
:[range]ma[rk] {a-zA-Z'} -- 把位置标记 {a-zA-Z'} 设在 [range] 的最后一行，第 0列。缺省的 [range] 是当前行。
:[range]k{a-zA-Z'}       -- 和 :mark 相同， 但是标记名之前的空格可以省略。
'{a-z} 或 `{a-z}         -- 跳转到当前缓冲区的位置标记 {a-z}。
'{A-Z0-9} 或 `{A-Z0-9}   -- 跳转到设置位置标记 {A-Z0-9} 的文件所在的标记位置 (如果切换到另外一个文件，这就不是动作命令)
g'{mark} 或 g`{mark}     -- 跳转到指定的位置标记 {mark}，但在当前缓冲区内跳转时，不改变跳转表
:marks                   -- 列出所有的位置标记 (这不是动作命令)，但不包括 '(，')，'{ 和 '} 标记。第一列的编号为零。
:marks {arg}             -- 列出所有 {arg} 包含的位置标记 (这不是动作命令)。例如，:marks aB 列出位置标记 'a' 和 'B'
:delm[arks] {marks}      -- 删除指定的位置标记。可以删除的位置标记也包括 A-Z 或0-9。不能删除 ' 位置标记。指定的方式包括给出位置标记名的列表和使用连字符分隔的范围。忽略空格。例如: >
    :delmarks a          -- 删除位置标记 a
    :delmarks a b 1      -- 删除位置标记 a，b 和 1
    :delmarks Aa         -- 删除位置标记 A 和 a
    :delmarks p-z        -- 删除位置标记 p 到 z
    :delmarks ^.[]       -- 删除位置标记 ^ . [ ]
    :delmarks \"         -- 删除位置标记 "
:delm[arks]!             -- 删除当前缓冲区所有的位置标记，不包括 A-Z 或 0-9 位置标记。
'a - 'z                  -- 小写位置标记，在每个文件内有效。
'A - 'Z                  -- 大写位置标记，也叫做文件标记，在文件间都有效。
'0 - '9                  -- 数字位置标记，在 .viminfo 文件里设置。

    只要文件还在缓冲区列表里，小写位置标记 'a 到 'z 就被记住。换而言之，如果在缓冲区列表里删除一个文件，它的位置标记就消失了。如果删除包含某个位置标记的文本行，这个位置标记也就随之消失。

    小写位置标记可以和操作符合并使用。例如，"d't" 删除从光标位置到包含 't 标记的文本行。提示: 用 't' 标记代表顶部 (Top)，'b' 标记代表底部 (Bottom)，等等。小写位置标记在撤销/重做时会被复原。

    大写位置标记 'A 到 'Z 包含了所在的文件名。可以用这些标记在文件间跳转。要和操作符合并使用的大写位置标记必须在当前文件里。即使插入/删除一些行或者同时编辑别的文件，这种标记的行号总是正确的。如果 'viminfo' 选项不为空，大写位置标记由 .viminfo 文件保存。

    数字位置标记 '0 到 '9 很不一样。它们不是直接设置，而只能从 viminfo 文件viminfo-file 中获取。简单的说，'0 是你上次离开 Vim 时的光标位置。'1 是再上一次，等等。'viminfo' 的 'r' 标志可以指定不记录数字位置标记的文件。

'[  `[          -- 到上次改变或者抽出的文本的第一个字符
']  `]          -- 到上次改变或者抽出文本的最后一个字符

    执行完一个操作符后，光标放在操作文本的开始。执行完一个放置命令 ("p" 或者"P")，光标有时放在第一个被插入的位置，有时放在最后一个。上述四个命令可以把光标放在两端的任何一端。例如，在抽出 10 行后，你想要到跳转到最后一行: "10Y']"。在用 "p" 插入数行后你想跳到最底下的那行: "p']"。这对插入的文本也可以。

请 注意: 在删除文本后，除非是面向列块的可视模式，开始和结束的位置是重合的。而如果没有任何改变，这四个命令不会有任何作用。

'<  `< -- 到上次当前缓冲区选择的可视区域首行或第一个字符。对于列块模式而言，可能也是第一行的最后一个字符 (为了能定义列块)。
'>  `> -- 到上次当前缓冲区选择的可视区域末行或最后一个字符。对于列块模式而言，可能也是末行的第一个字符 (为了能定义列块)。
''  `` -- 到上次跳转的位置，或者上次 "m'" 或者 "m`" 命令给出的位置。如果使用了 :keepjumps 命令修饰符，这个前次上下文标记不会被改变。
'"  `" -- 到上次离开本缓冲区时的光标位置。缺省是第一行的第一个字符。 参见 last-position-jump 以了解如何对所有刚打开的文件使用这个标记。每个缓冲区，而不是每个窗口，只有一个记住的位置。只要这个缓冲区在某一个窗口可见，这个标记是不会改变的。
'^  `^ -- 到上次插入模式关闭的光标位置。gi 命令用到这个标记。如果使用了 :keepjumps 命令修饰符，这个标记不会改变。
'.  `. -- 到上次改变的位置。这个位置位于或者接近于改变开始的地方。有些命令引起几个改变，那么这个位置应该是接近于这个命令最后改变的地方。例如，插入一个单词的时候，这个位置是在最后一个的字符上。
'(  `( -- 到当前句子的开始处，就像 ( 命令
')  `) -- 到当前句子的结尾处，就像 ) 命令
'{  `{ -- 到当前段落的开始处，就像 { 命令
'}  `} -- 到当前段落的结尾处，就像 } 命令

这些命令不是标记本身，而是实现对某个标记的跳转:
]'                     -- [count] 次到当前行之后下一个包含小写位置标记的行的第一个非空白字符
]`                     -- [count] 次下一个小写位置标记
['                     -- [count] 次到当前行之前上一个包含小写位置标记的行的第一个非空白字符
[`                     -- [count] 次上一个小写位置标记
:loc[kmarks] {command} -- 执行命令 {command}，并且不调整位置标记。这可以用于不影响行的数目的文本改变。如果行数发生变化，那么改变之后的标记将仍然保持它们的行号，从而实际上移到了别的行上。

以下各项对于插入/删除行不会被调整:
    - 小写位置标记 'a - 'z
    - 大写位置标记 'A - 'Z
    - 数字位置标记 '0 - '9
    - 上次插入位置 '^
    - 上次改变位置 '.
    - 可视选择区域 '< 和 '>
    - 已设定的标号 signs 的行号
    - quickfix 位置的行号
    - 跳转表 jumplist 里的位置
    - 标签堆栈 tagstack 里的位置

以下各项则总会被调整:
    - 前次上下文标记 ''
    - 光标位置
    - 窗口或者缓冲区的视图
    - 折叠 folding
    - 差异视图 diff

:kee[pmarks] {command}   -- 目前，这只对过滤命令 :range! 有效:
                         -- - 如果过滤后的行数不少于过滤之前，那么所有的过滤行中的标记保持行号不变。
                         -- - 如果行数减少，那么消失了的行中的标记就被删除掉。
                         -- 在任何情况下，过滤文本之后的标记需要调整行号，以保持和文本同步。
:keepj[umps] {command}   -- 在 {command} 的移动不改变 ''，'. 和 '^ 标记，跳转表 jumplist 或是改变表 changelist。
                         -- 这对于自动改变或者插入文本而不需要用户跳转到那个位置有用。
                         -- 例如，当更新 "最近改变" 的时间标签: >
    :let lnum = line(".")
    :keepjumps normal gg
    :call SetLastChange()
    :keepjumps exe "normal " . lnum . "G"
<
==============================================================================
8. 跳转

"跳转" 包括如下的命令:
     "'"、"`"、"G"、"/"、"?"、"n"、"N"、"%"、"("、")"、"[["、"]]"、"{"、"}"、":s"、":tag"、"L"、"M"、"H" 和开始编辑新文件的命令。
    如果用这些命令使光标 "跳转"，那么跳转之前的光标位置会被记住。
    除非包含该位置的行被改变或者删除，你可以用 "''" 和 "``" 命令返回这个位置。

CTRL-O --转到跳转表里第 [count] 个较旧的光标位置(不是动作命令)
<Tab> 或 CTRL-I --转到跳转表里第 [count] 个较新的光标位置(不是动作命令)。
:ju[mps] --打出跳转表 (不是动作命令)

    跳转表用来记住跳转的位置。用 CTRL-O 和 CTRL-I 命令，你可以跳回到较早前的跳转位置，然后在跳回来。
    这样，你就可以在这个列表上下移动。每个窗口有独立的跳转表，每个表最多能存储 100 项。

改变表跳转

    在改变文本以后，光标的位置被记住。每个改变都会记住一个位置，从而可以使该操作能被撤销。除非，这个位置和上一个改变很接近。可以用两个命令跳转到改变所在的位置，包括那些已被撤销的:

g; -- 转到改变表里第 [count] 个较旧的位置。如果 [count] 比所有的较旧的改变位置都多，回到最老的那个。如果没有较旧的改变，给出一个错误消息。
g, -- 转到改变表里第 [count] 个较新的位置。和 g; 类似，但朝向相反的方向。

    使用次数的时候你向后或向前跳转到尽可能接近该次数的位置。这样，你可以用 "999g;"跳到还能记住的最初的改变所在的位置。改变的最大项目数和跳转表 jumplist 一致。

    当两个可以撤销的改变在同一行，并且所在的列差小于 'textwidth'，只有后一个会被记住。这可以避免同一行里一系列很小的改变，例如 "xxxxx"，在改变表里占据很多位置。
    如果 'textwidth' 为 0，则使用 'wrapmargin'。如果它也没有设置，就用固定的数目79。细节: 考虑到速度的影响，计算用的是字节数而不是字符数 (这只对多字节编码有意义)。

请 注意 如果后来有插入和删除文本，尤其删除整行的时候，光标位置和当时改变的位置可能稍有不同。

如果用到 :keepjumps 命令修饰符，改变的位置不会被记住。
:changes  -- 打出改变表。
          -- ">" 字符指示当前的位置。在一个改变之后，它在最新的一项之后，这意味着 "g;" 会带你到最新一项的位置。第一列则指示要到该位置需要的次数。
          -- 例如:
        change line  col text ~
        3     9    8 bla bla bla
        2    11   57 foo is a bar
        1    14   54 最新改变的行

        "3g;" 命令会带你到第 9 行。这时，":changes" 的结果是:

        change line  col text ~
        >   0     9    8 bla bla bla
        1    11   57 foo is a bar
        2    14   54 最新改变的行

        现在你可以用 "g," 到第 11 行，"2g," 到第 14 行。

==============================================================================
9. 其他动作

% --找到本行的光标所在或其后的下一个项目，并跳转到它的匹配。
    项目可以是:
     ([{}])                            -- 小括号或者 (花/方) 括号。
     /* */                             -- C-风格的注释的开始或结尾
     #if、#ifdef、#else、#elif、#endif -- C 预处理条件宏 (光标在 # 上，或者其后没有 ([{ 的时候)

[( -- 反向第 [count] 个的未匹配的 '('。exclusive 开动作
[{ -- 反向第 [count] 个的未匹配的 '{'。exclusive 开动作
]) -- 正向第 [count] 个的未匹配的 ')'。exclusive 开动作
]} -- 正向第 [count] 个的未匹配的 '}'。exclusive 开动作

以上四个命令用于转到当前代码块的开始或者结尾位置。
这和在 '('、')'、'{' 或 '}'上用 "%" 类似，但你可以在代码块的任何位置这么做，这对 C 程序很有用。
例如: 在"case x:" 上用 "[{" 会把你带回到 switch 语句上。

]m -- 正向第 [count] 个方法 (method) 的开始处 (适用于 Java或类似结构的语言)。
]M -- 正向第 [count] 个方法的结束处 (适用于 Java 或类似结构的语言)。
[m -- 反向第 [count] 个方法的开始处 (适用于 Java 或类似结构的语言)。
[M -- 反向第 [count] 个方法的结束处 (适用于 Java 或类似结构的语言)。

以上这些命令假设文件包含一个有方法的类定义。类定义用 '{' 和 '}' 包围，而方法定义亦然。Java 语言便是如此。
    源文件看起来应像这样: >
    // 注释
    class foo {
    int method_one() {
    body_one();
    }
    int method_two() {
    body_two();
    }
    }
开始，光标在 "body_two()" 上，用 "[m" 会跳转到 "method_two()" 开始的那个 '{'(显然，如果方法定义很长，这就更有用！)。
用 "2[m" 会跳转到 "method_one()" 的开始处。用 "3[m" 会跳转到类的开始处。

[# --反向第 [count] 个未匹配的 "#if" 或 "#else"。
]# --正向第 [count] 个未匹配的 "#else" 或 "#endif"。

这两个命令对有 #if/#else/#endif 结构的 C 程序很有用。
它们把你带到当前行所在的#if/#else/#endif 的开始或结束处。然后，你可以用 "%" 找到相匹配的行。

[*  或  [/ -- 反向第 [count] 个 C 注释的开始 "/*"。
]*  或  ]/ -- 正向第 [count] 个 C 注释的结束 "*/"。
H          -- 到窗口从顶部 (Home) 算第 [count] 行 (缺省: 窗口的第一行) 并停在第一个非空白字符上。linewise 行动作。
M          -- 到窗口的中间 (Middle) 一行并停在第一个非空白字符。
L          -- 到窗口从底部 (Last) 算第 [count] 行 (缺省: 窗口的最后一行) 并停在第一个非空白字符上。linewise 行动作。
