让vim代替你的双手（备忘笔记）


.(英文句号) - 简单，快捷
.（英文句号） 用于实现最简单的重复工作。原理上，vim会记住你最近一次“编辑动作”，使用.（英文句号）可以回放之。要注意的是，“进入插 入模式，然后作若干修改，最后离开编辑模式” 被认为是 1 次编辑动作，譬如说，你现在处于正常模式，然后你按i进入插入模式，接着你敲击键盘，输入了 “hello”，最后你按Esc回到正常模式，那么，vim记住了你最近的一次编辑动作是”你按下i开始直到你按下Esc为止的所有击键序列“。

用一个例子说明 . 的用法：
假设你需要将当前文件中的所有 teh 替换成 the。正常模式下，你输入 /\<teh\>，回车，光标跳到了第一个最近的 “teh”的t上。你按下i，然后按3次delete键，然后输入the，然后按esc回到正常模式。接着，你按下n，光标跳到了下一个最近的 “teh”，然后你按 . ，看，那个teh马上被替换成the了。于是，你重复地按下n和.，直到所有的teh都被替换完。


====================================================================================================================================================


s - 智力游戏，趣味盎然
s命令（全称为substitute）是一个非常非常非常（省略若干个非常）有用的命令，配合vim神速的正则匹配，绝对是你居家旅行，杀人越货之必备良品。

s命令的格式是：
:[range]s/{pattern}/{string}/[flags] [count]
其中，pattern 是要匹配的正则表达式，如果留空则表示和上一次s命令使用相同的正则表达式。而string则是要替换的字符串。
各个参数的含义请客官自行:h :s
如果要重复上一次的s命令，只需要简单地输入":s", 然后回车。

要用好s命令，首先要学会使用正则表达式。
组成正则表达式的常用元素有(来自vim-help手册)：

^ 匹配行首，也就是一行里的第一个字符前面的“夹缝”
$ 匹配行尾，也就是一行里的最后一个字符后面的“夹缝”，“夹缝”后面跟着换行符或者文件的结束处。
\zs 匹配任何位置，并将匹配起始处置于该处: 下一个字符将是整个匹配的第一个字符。
\ze 匹配任何位置，并将匹配结尾处置于该处: 前一个字符将是整个匹配的最后一个字符。


\%$ 匹配文件尾。当用于一个字符串时，匹配字符串结束处。
\%23l 匹配指定的行。
\%23c 匹配指定的列。
\%23v 匹配指定虚拟列。


. 匹配除换行符以外的任何字符
\n 匹配行尾符
\s 空白字符； <Space> 和 <Tab>
\S 非空白字符：\s 之反
\d 数位: [0-9]
\D 非数位: [^0-9]
\x 十六进制数位: [0-9A-Fa-f]
\X 非十六进制数位: [^0-9A-Fa-f]
\o 八进制数位: [0-7]
\O 非八进制数位: [^0-7]
\w 单词字符: [0-9A-Za-z_]
\W 非单词字符: [^0-9A-Za-z_]
\h 单词首字符: [A-Za-z_]
\H 非单词首字符: [^A-Za-z_]
\a 英文字母字符: [A-Za-z]
\A 非英文字母字符: [^A-Za-z]
\l 小写字符: [a-z]
\L 非小写字符: [^a-z]
\u 大写字符: [A-Z]
\U 非大写字符 [^A-Z]


* 匹配 0 或更多个前面的匹配原，尽可能多地匹配。
\+ 匹配一个或更多前面的匹配原。尽可能多。
\= 匹配 0 或 1 个前面的匹配原。尽可能多。
\{n,m} 匹配 n 至 m 个前面的匹配原。尽可能多
\{n} 匹配 n 个前面的匹配原
\{n,} 匹配至少 n 个前面的匹配原。尽可能多
\{,m} 匹配 0 至 m 个前面的匹配原。尽可能多
\{-n,m} 匹配 n 至 m 个前面的匹配原。尽可能少
\{-n} 匹配 n 个前面的匹配原
\{-n,} 匹配至少 n 个前面的匹配原。尽可能少
\{-,m} 匹配 0 至 m 个前面的匹配原。尽可能少
\{-} 匹配 0 个以上前面的匹配原。尽可能少


\(\) 一个由转义的括号括起来的模式。例："\(^a\)" 匹配行首的 'a'。
\%(\) 一个由转义的括号括起来的模式。类似 \(\)，但不算作一个子表达式。这样做允许使用更多的群组，并且处理时会稍快些。


还有许多神奇的东西，请客官自行:h

其次，string有一些特殊的可用元素：
& 替换为完整的匹配
\0 同上
\1   替代为匹配的第一个 () 里面的内容
...
\9   替代为匹配的第九个 () 里面的内容
~   替代为前一个 substitute 的替代字符串(你要知道，当你将string留空时，其实是会删除被匹配的字符串)
\u   下一个字符成为大写
\U   其后字符成为大写，直到 \e 出现
\l   下一个字符成为小写
\L   其后字符成为小写，直到 \e 出现
\e   结束 \u、\U、\l 和 \L (注意: 不是 <Esc>!)
\r   把该行在此位置一分为二
\b   插入一个 <BS>
\t   插入一个 <Tab>
\\   插入单个反斜杠


要注意的是，在pattern里，行尾符是用 \n 表示的，而在string里，行尾符是用 \r 来表示！
还有许多神奇的东西，请客官自行:h

接着，要提到一个异常强大的替换技巧：\= 使用表达式的计算结果来生成替换
当 string 以\=开头，那么string的剩余部分将被看成是一个表达式，vim会计算该表达式，然后将结果作为替换字符串。
在该表达式中，可以使用函数submatch(n) 来获取第n个子匹配，也就是说，submatch(0) 等于 \0，submatch(1)等于 \1，以此类推。
如果 表达式的返回值是一个 list，那么相当于返回了一个以换行符连接该list的元素的字符串，例如 如果返回值是 [1, "abc", 0]，相当于返回值 "1\rabc\r0"
举个例子说，我们有时候会需要生成类似于下面这种数字序列：
5
6
7
...
100
在vim里，要生成这个序列，有很多种方法，其中一种是：
:s/^/\=range(5, 100)
类似地，可以生成步进为2的：
:s/^/\=range(5, 100, 2)


最后是使用s命令的例子：
vim并没有提供“保存文件时保证文件以换行符结束”这个选项，但是我们自己可以用自动命令和s命令做一个。在你的.vimrc里加上下面这句
autocmd BufWritePre * sil $s/.$/&\r/e
其中，
autocmd BufWritePre * 表示后面的动作发生具有任何名字的文件保存之前
sil 表示后面的动作以静默方式执行（没有反馈消息）
$s/.$/&\r/e 第一个$表示这个s命令的应用范围只是文件的最后一行，然后 .$ 表示匹配一个在行尾前面的字符，而 &\r表示替换为“完整匹配后跟一个换行符”，e 表示即使找不到匹配，也不会产生错误消息

这个s命令的思路是：假设文件尾不是以换行符结束，那么文件的最后一行必然是非空行（长度非0的行），那么，我们可以为文件最后一行添加一个换行符:)

类似地，我们可以使用s命令和自动命令来让vim在我们保存文件之前做特定的”修饰“：
"保存文件时自动删除行尾空格或Tab
au BufWritePre * sil %s/\s\+$//e
"自动为文件加上最后修改时间
au BufWritePre * exe 'sil! 1,' . min([line('$'), 20]) . 's/^\S\+\s\+Last modified: \zs.*/\=strftime("%y-%m-%d %H:%M:%S")/e'
"删除文件尾多余的空行
au BufWritePre * %s/^$\n\+\%$//ge


====================================================================================================================================================


宏 - 善待你的脑细胞
有时候，对于一些实现思路并不那么明显的处理，使用s命令会杀死很多无辜的脑细胞，于是，本着KISS原则，我们可以使用宏来实现重复。
宏的使用很简单，自行 :h 就行。记住@@是重复上一次宏。
有两个技巧可以令宏作用在连续的若干行：
1，如果一个宏结束后，光标最终停留在宏开始时的那一行的下一行，那这个宏可以用来对连续行进行操作。
2，使用normal @a 命令可以令宏作用在若干连续行(a为任意寄存器)。

最后还是举个简单的例子吧，例如，我们有一个包含100行的文件：
1
2
...
100

我们想要将它们变成：
.\img\1.gif
.\img\2.gif
...
.\img\100.gif

首先，我们将光标移到第一行，按qq，进入宏录制，按^，光标跳到了行首，按i，键入.\img\，按esc，按$，光标跳到了行尾，按a，键入.gif，按esc，按q，结束宏录制并回到正常模式。
然后，我们按冒号:，输入 2,100normal @q，回车。
就算你刚睡醒，这个方法依然有效，因为一切都是那么简单直接。
同样的效果，如果我们使用s命令：
:%s/.*/.\\img\\&.gif


====================================================================================================================================================


g - 最终boss
很多命令都支持”行范围“，但是行范围一般只可以表示连续的若干行，如果我们需要只对”符合某种条件“的行进行批量操作，行范围就无能为力了，而g命令则可以做到这一点。
g命令的一般格式是:
:[range]g/{pattern}/[cmd]

这么牛逼的东西，只有:h才能说明白。
要注意的是，g的默认range是全文件，而不是当前行。而且，cmd可以是任何命令，注意，是”任何“！，也就是说，你甚至可以在cmd里使用s命令，normal命令，从而达到很多神奇的效果。

例如，要消除连续的重复行可以这样：
:g/^\(.*\)\n\1$/d

更多的g命令和s命令的例子，可以参考：
http://www.rayninfo.

co.uk/vimtips.html



====================================================================================================================================================

递归map, windo, bufdo, tabdo, argdo - 多文件的批处理
用法很简单，请自行:h。

==================================================================================================================================================== 

假设要生成1至100间的所有奇数，

s命令：
:%s/^/\=range(1,100,2) 
:%s/^/\=line('.') * 2 - 1

表达式寄存器(这应该是最简单的方法了)：
在插入模式下，输入 <C-R>=range(1,100,2)，回车

宏：
先修改第一行的内容为"1"。正常模式下，光标移到第一行，录制宏：
qqyyp<c-a><c-a>q
然后重复这个宏50次：50@q

用g命令:
:let i=1
:g/^/s/^/\=i | let i = i + 2
